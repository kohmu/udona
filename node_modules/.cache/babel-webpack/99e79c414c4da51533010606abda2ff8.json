{"ast":null,"code":"// flex-buffer.js\nexports.FlexDecoder = FlexDecoder;\nexports.FlexEncoder = FlexEncoder;\n\nvar Bufferish = require(\"./bufferish\");\n\nvar MIN_BUFFER_SIZE = 2048;\nvar MAX_BUFFER_SIZE = 65536;\nvar BUFFER_SHORTAGE = \"BUFFER_SHORTAGE\";\n\nfunction FlexDecoder() {\n  if (!(this instanceof FlexDecoder)) return new FlexDecoder();\n}\n\nfunction FlexEncoder() {\n  if (!(this instanceof FlexEncoder)) return new FlexEncoder();\n}\n\nFlexDecoder.mixin = mixinFactory(getDecoderMethods());\nFlexDecoder.mixin(FlexDecoder.prototype);\nFlexEncoder.mixin = mixinFactory(getEncoderMethods());\nFlexEncoder.mixin(FlexEncoder.prototype);\n\nfunction getDecoderMethods() {\n  return {\n    bufferish: Bufferish,\n    write: write,\n    fetch: fetch,\n    flush: flush,\n    push: push,\n    pull: pull,\n    read: read,\n    reserve: reserve,\n    offset: 0\n  };\n\n  function write(chunk) {\n    var prev = this.offset ? Bufferish.prototype.slice.call(this.buffer, this.offset) : this.buffer;\n    this.buffer = prev ? chunk ? this.bufferish.concat([prev, chunk]) : prev : chunk;\n    this.offset = 0;\n  }\n\n  function flush() {\n    while (this.offset < this.buffer.length) {\n      var start = this.offset;\n      var value;\n\n      try {\n        value = this.fetch();\n      } catch (e) {\n        if (e && e.message != BUFFER_SHORTAGE) throw e; // rollback\n\n        this.offset = start;\n        break;\n      }\n\n      this.push(value);\n    }\n  }\n\n  function reserve(length) {\n    var start = this.offset;\n    var end = start + length;\n    if (end > this.buffer.length) throw new Error(BUFFER_SHORTAGE);\n    this.offset = end;\n    return start;\n  }\n}\n\nfunction getEncoderMethods() {\n  return {\n    bufferish: Bufferish,\n    write: write,\n    fetch: fetch,\n    flush: flush,\n    push: push,\n    pull: pull,\n    read: read,\n    reserve: reserve,\n    send: send,\n    maxBufferSize: MAX_BUFFER_SIZE,\n    minBufferSize: MIN_BUFFER_SIZE,\n    offset: 0,\n    start: 0\n  };\n\n  function fetch() {\n    var start = this.start;\n\n    if (start < this.offset) {\n      var end = this.start = this.offset;\n      return Bufferish.prototype.slice.call(this.buffer, start, end);\n    }\n  }\n\n  function flush() {\n    while (this.start < this.offset) {\n      var value = this.fetch();\n      if (value) this.push(value);\n    }\n  }\n\n  function pull() {\n    var buffers = this.buffers || (this.buffers = []);\n    var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];\n    buffers.length = 0; // buffer exhausted\n\n    return chunk;\n  }\n\n  function reserve(length) {\n    var req = length | 0;\n\n    if (this.buffer) {\n      var size = this.buffer.length;\n      var start = this.offset | 0;\n      var end = start + req; // is it long enough?\n\n      if (end < size) {\n        this.offset = end;\n        return start;\n      } // flush current buffer\n\n\n      this.flush(); // resize it to 2x current length\n\n      length = Math.max(length, Math.min(size * 2, this.maxBufferSize));\n    } // minimum buffer size\n\n\n    length = Math.max(length, this.minBufferSize); // allocate new buffer\n\n    this.buffer = this.bufferish.alloc(length);\n    this.start = 0;\n    this.offset = req;\n    return 0;\n  }\n\n  function send(buffer) {\n    var length = buffer.length;\n\n    if (length > this.minBufferSize) {\n      this.flush();\n      this.push(buffer);\n    } else {\n      var offset = this.reserve(length);\n      Bufferish.prototype.copy.call(buffer, this.buffer, offset);\n    }\n  }\n} // common methods\n\n\nfunction write() {\n  throw new Error(\"method not implemented: write()\");\n}\n\nfunction fetch() {\n  throw new Error(\"method not implemented: fetch()\");\n}\n\nfunction read() {\n  var length = this.buffers && this.buffers.length; // fetch the first result\n\n  if (!length) return this.fetch(); // flush current buffer\n\n  this.flush(); // read from the results\n\n  return this.pull();\n}\n\nfunction push(chunk) {\n  var buffers = this.buffers || (this.buffers = []);\n  buffers.push(chunk);\n}\n\nfunction pull() {\n  var buffers = this.buffers || (this.buffers = []);\n  return buffers.shift();\n}\n\nfunction mixinFactory(source) {\n  return mixin;\n\n  function mixin(target) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n}","map":{"version":3,"sources":["C:/Users/kohmu/udonarium/node_modules/msgpack-lite/lib/flex-buffer.js"],"names":["exports","FlexDecoder","FlexEncoder","Bufferish","require","MIN_BUFFER_SIZE","MAX_BUFFER_SIZE","BUFFER_SHORTAGE","mixin","mixinFactory","getDecoderMethods","prototype","getEncoderMethods","bufferish","write","fetch","flush","push","pull","read","reserve","offset","chunk","prev","slice","call","buffer","concat","length","start","value","e","message","end","Error","send","maxBufferSize","minBufferSize","buffers","req","size","Math","max","min","alloc","copy","shift","source","target","key"],"mappings":"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","sourcesContent":["// flex-buffer.js\n\nexports.FlexDecoder = FlexDecoder;\nexports.FlexEncoder = FlexEncoder;\n\nvar Bufferish = require(\"./bufferish\");\n\nvar MIN_BUFFER_SIZE = 2048;\nvar MAX_BUFFER_SIZE = 65536;\nvar BUFFER_SHORTAGE = \"BUFFER_SHORTAGE\";\n\nfunction FlexDecoder() {\n  if (!(this instanceof FlexDecoder)) return new FlexDecoder();\n}\n\nfunction FlexEncoder() {\n  if (!(this instanceof FlexEncoder)) return new FlexEncoder();\n}\n\nFlexDecoder.mixin = mixinFactory(getDecoderMethods());\nFlexDecoder.mixin(FlexDecoder.prototype);\n\nFlexEncoder.mixin = mixinFactory(getEncoderMethods());\nFlexEncoder.mixin(FlexEncoder.prototype);\n\nfunction getDecoderMethods() {\n  return {\n    bufferish: Bufferish,\n    write: write,\n    fetch: fetch,\n    flush: flush,\n    push: push,\n    pull: pull,\n    read: read,\n    reserve: reserve,\n    offset: 0\n  };\n\n  function write(chunk) {\n    var prev = this.offset ? Bufferish.prototype.slice.call(this.buffer, this.offset) : this.buffer;\n    this.buffer = prev ? (chunk ? this.bufferish.concat([prev, chunk]) : prev) : chunk;\n    this.offset = 0;\n  }\n\n  function flush() {\n    while (this.offset < this.buffer.length) {\n      var start = this.offset;\n      var value;\n      try {\n        value = this.fetch();\n      } catch (e) {\n        if (e && e.message != BUFFER_SHORTAGE) throw e;\n        // rollback\n        this.offset = start;\n        break;\n      }\n      this.push(value);\n    }\n  }\n\n  function reserve(length) {\n    var start = this.offset;\n    var end = start + length;\n    if (end > this.buffer.length) throw new Error(BUFFER_SHORTAGE);\n    this.offset = end;\n    return start;\n  }\n}\n\nfunction getEncoderMethods() {\n  return {\n    bufferish: Bufferish,\n    write: write,\n    fetch: fetch,\n    flush: flush,\n    push: push,\n    pull: pull,\n    read: read,\n    reserve: reserve,\n    send: send,\n    maxBufferSize: MAX_BUFFER_SIZE,\n    minBufferSize: MIN_BUFFER_SIZE,\n    offset: 0,\n    start: 0\n  };\n\n  function fetch() {\n    var start = this.start;\n    if (start < this.offset) {\n      var end = this.start = this.offset;\n      return Bufferish.prototype.slice.call(this.buffer, start, end);\n    }\n  }\n\n  function flush() {\n    while (this.start < this.offset) {\n      var value = this.fetch();\n      if (value) this.push(value);\n    }\n  }\n\n  function pull() {\n    var buffers = this.buffers || (this.buffers = []);\n    var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];\n    buffers.length = 0; // buffer exhausted\n    return chunk;\n  }\n\n  function reserve(length) {\n    var req = length | 0;\n\n    if (this.buffer) {\n      var size = this.buffer.length;\n      var start = this.offset | 0;\n      var end = start + req;\n\n      // is it long enough?\n      if (end < size) {\n        this.offset = end;\n        return start;\n      }\n\n      // flush current buffer\n      this.flush();\n\n      // resize it to 2x current length\n      length = Math.max(length, Math.min(size * 2, this.maxBufferSize));\n    }\n\n    // minimum buffer size\n    length = Math.max(length, this.minBufferSize);\n\n    // allocate new buffer\n    this.buffer = this.bufferish.alloc(length);\n    this.start = 0;\n    this.offset = req;\n    return 0;\n  }\n\n  function send(buffer) {\n    var length = buffer.length;\n    if (length > this.minBufferSize) {\n      this.flush();\n      this.push(buffer);\n    } else {\n      var offset = this.reserve(length);\n      Bufferish.prototype.copy.call(buffer, this.buffer, offset);\n    }\n  }\n}\n\n// common methods\n\nfunction write() {\n  throw new Error(\"method not implemented: write()\");\n}\n\nfunction fetch() {\n  throw new Error(\"method not implemented: fetch()\");\n}\n\nfunction read() {\n  var length = this.buffers && this.buffers.length;\n\n  // fetch the first result\n  if (!length) return this.fetch();\n\n  // flush current buffer\n  this.flush();\n\n  // read from the results\n  return this.pull();\n}\n\nfunction push(chunk) {\n  var buffers = this.buffers || (this.buffers = []);\n  buffers.push(chunk);\n}\n\nfunction pull() {\n  var buffers = this.buffers || (this.buffers = []);\n  return buffers.shift();\n}\n\nfunction mixinFactory(source) {\n  return mixin;\n\n  function mixin(target) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}