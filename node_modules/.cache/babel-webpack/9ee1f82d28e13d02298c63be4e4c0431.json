{"ast":null,"code":"// bufferish-proto.js\n\n/* jshint eqnull:true */\nvar BufferLite = require(\"./buffer-lite\");\n\nexports.copy = copy;\nexports.slice = slice;\nexports.toString = toString;\nexports.write = gen(\"write\");\n\nvar Bufferish = require(\"./bufferish\");\n\nvar Buffer = Bufferish.global;\nvar isBufferShim = Bufferish.hasBuffer && \"TYPED_ARRAY_SUPPORT\" in Buffer;\nvar brokenTypedArray = isBufferShim && !Buffer.TYPED_ARRAY_SUPPORT;\n/**\n * @param target {Buffer|Uint8Array|Array}\n * @param [targetStart] {Number}\n * @param [start] {Number}\n * @param [end] {Number}\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction copy(target, targetStart, start, end) {\n  var thisIsBuffer = Bufferish.isBuffer(this);\n  var targetIsBuffer = Bufferish.isBuffer(target);\n\n  if (thisIsBuffer && targetIsBuffer) {\n    // Buffer to Buffer\n    return this.copy(target, targetStart, start, end);\n  } else if (!brokenTypedArray && !thisIsBuffer && !targetIsBuffer && Bufferish.isView(this) && Bufferish.isView(target)) {\n    // Uint8Array to Uint8Array (except for minor some browsers)\n    var buffer = start || end != null ? slice.call(this, start, end) : this;\n    target.set(buffer, targetStart);\n    return buffer.length;\n  } else {\n    // other cases\n    return BufferLite.copy.call(this, target, targetStart, start, end);\n  }\n}\n/**\n * @param [start] {Number}\n * @param [end] {Number}\n * @returns {Buffer|Uint8Array|Array}\n */\n\n\nfunction slice(start, end) {\n  // for Buffer, Uint8Array (except for minor some browsers) and Array\n  var f = this.slice || !brokenTypedArray && this.subarray;\n  if (f) return f.call(this, start, end); // Uint8Array (for minor some browsers)\n\n  var target = Bufferish.alloc.call(this, end - start);\n  copy.call(this, target, 0, start, end);\n  return target;\n}\n/**\n * Buffer.prototype.toString()\n *\n * @param [encoding] {String} ignored\n * @param [start] {Number}\n * @param [end] {Number}\n * @returns {String}\n */\n\n\nfunction toString(encoding, start, end) {\n  var f = !isBufferShim && Bufferish.isBuffer(this) ? this.toString : BufferLite.toString;\n  return f.apply(this, arguments);\n}\n/**\n * @private\n */\n\n\nfunction gen(method) {\n  return wrap;\n\n  function wrap() {\n    var f = this[method] || BufferLite[method];\n    return f.apply(this, arguments);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}