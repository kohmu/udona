{"ast":null,"code":"// write-type.js\nvar IS_ARRAY = require(\"isarray\");\n\nvar Int64Buffer = require(\"int64-buffer\");\n\nvar Uint64BE = Int64Buffer.Uint64BE;\nvar Int64BE = Int64Buffer.Int64BE;\n\nvar Bufferish = require(\"./bufferish\");\n\nvar BufferProto = require(\"./bufferish-proto\");\n\nvar WriteToken = require(\"./write-token\");\n\nvar uint8 = require(\"./write-uint8\").uint8;\n\nvar ExtBuffer = require(\"./ext-buffer\").ExtBuffer;\n\nvar HAS_UINT8ARRAY = \"undefined\" !== typeof Uint8Array;\nvar HAS_MAP = \"undefined\" !== typeof Map;\nvar extmap = [];\nextmap[1] = 0xd4;\nextmap[2] = 0xd5;\nextmap[4] = 0xd6;\nextmap[8] = 0xd7;\nextmap[16] = 0xd8;\nexports.getWriteType = getWriteType;\n\nfunction getWriteType(options) {\n  var token = WriteToken.getWriteToken(options);\n  var useraw = options && options.useraw;\n  var binarraybuffer = HAS_UINT8ARRAY && options && options.binarraybuffer;\n  var isBuffer = binarraybuffer ? Bufferish.isArrayBuffer : Bufferish.isBuffer;\n  var bin = binarraybuffer ? bin_arraybuffer : bin_buffer;\n  var usemap = HAS_MAP && options && options.usemap;\n  var map = usemap ? map_to_map : obj_to_map;\n  var writeType = {\n    \"boolean\": bool,\n    \"function\": nil,\n    \"number\": number,\n    \"object\": useraw ? object_raw : object,\n    \"string\": _string(useraw ? raw_head_size : str_head_size),\n    \"symbol\": nil,\n    \"undefined\": nil\n  };\n  return writeType; // false -- 0xc2\n  // true -- 0xc3\n\n  function bool(encoder, value) {\n    var type = value ? 0xc3 : 0xc2;\n    token[type](encoder, value);\n  }\n\n  function number(encoder, value) {\n    var ivalue = value | 0;\n    var type;\n\n    if (value !== ivalue) {\n      // float 64 -- 0xcb\n      type = 0xcb;\n      token[type](encoder, value);\n      return;\n    } else if (-0x20 <= ivalue && ivalue <= 0x7F) {\n      // positive fixint -- 0x00 - 0x7f\n      // negative fixint -- 0xe0 - 0xff\n      type = ivalue & 0xFF;\n    } else if (0 <= ivalue) {\n      // uint 8 -- 0xcc\n      // uint 16 -- 0xcd\n      // uint 32 -- 0xce\n      type = ivalue <= 0xFF ? 0xcc : ivalue <= 0xFFFF ? 0xcd : 0xce;\n    } else {\n      // int 8 -- 0xd0\n      // int 16 -- 0xd1\n      // int 32 -- 0xd2\n      type = -0x80 <= ivalue ? 0xd0 : -0x8000 <= ivalue ? 0xd1 : 0xd2;\n    }\n\n    token[type](encoder, ivalue);\n  } // uint 64 -- 0xcf\n\n\n  function uint64(encoder, value) {\n    var type = 0xcf;\n    token[type](encoder, value.toArray());\n  } // int 64 -- 0xd3\n\n\n  function int64(encoder, value) {\n    var type = 0xd3;\n    token[type](encoder, value.toArray());\n  } // str 8 -- 0xd9\n  // str 16 -- 0xda\n  // str 32 -- 0xdb\n  // fixstr -- 0xa0 - 0xbf\n\n\n  function str_head_size(length) {\n    return length < 32 ? 1 : length <= 0xFF ? 2 : length <= 0xFFFF ? 3 : 5;\n  } // raw 16 -- 0xda\n  // raw 32 -- 0xdb\n  // fixraw -- 0xa0 - 0xbf\n\n\n  function raw_head_size(length) {\n    return length < 32 ? 1 : length <= 0xFFFF ? 3 : 5;\n  }\n\n  function _string(head_size) {\n    return string;\n\n    function string(encoder, value) {\n      // prepare buffer\n      var length = value.length;\n      var maxsize = 5 + length * 3;\n      encoder.offset = encoder.reserve(maxsize);\n      var buffer = encoder.buffer; // expected header size\n\n      var expected = head_size(length); // expected start point\n\n      var start = encoder.offset + expected; // write string\n\n      length = BufferProto.write.call(buffer, value, start); // actual header size\n\n      var actual = head_size(length); // move content when needed\n\n      if (expected !== actual) {\n        var targetStart = start + actual - expected;\n        var end = start + length;\n        BufferProto.copy.call(buffer, buffer, targetStart, start, end);\n      } // write header\n\n\n      var type = actual === 1 ? 0xa0 + length : actual <= 3 ? 0xd7 + actual : 0xdb;\n      token[type](encoder, length); // move cursor\n\n      encoder.offset += length;\n    }\n  }\n\n  function object(encoder, value) {\n    // null\n    if (value === null) return nil(encoder, value); // Buffer\n\n    if (isBuffer(value)) return bin(encoder, value); // Array\n\n    if (IS_ARRAY(value)) return array(encoder, value); // int64-buffer objects\n\n    if (Uint64BE.isUint64BE(value)) return uint64(encoder, value);\n    if (Int64BE.isInt64BE(value)) return int64(encoder, value); // ext formats\n\n    var packer = encoder.codec.getExtPacker(value);\n    if (packer) value = packer(value);\n    if (value instanceof ExtBuffer) return ext(encoder, value); // plain old Objects or Map\n\n    map(encoder, value);\n  }\n\n  function object_raw(encoder, value) {\n    // Buffer\n    if (isBuffer(value)) return raw(encoder, value); // others\n\n    object(encoder, value);\n  } // nil -- 0xc0\n\n\n  function nil(encoder, value) {\n    var type = 0xc0;\n    token[type](encoder, value);\n  } // fixarray -- 0x90 - 0x9f\n  // array 16 -- 0xdc\n  // array 32 -- 0xdd\n\n\n  function array(encoder, value) {\n    var length = value.length;\n    var type = length < 16 ? 0x90 + length : length <= 0xFFFF ? 0xdc : 0xdd;\n    token[type](encoder, length);\n    var encode = encoder.codec.encode;\n\n    for (var i = 0; i < length; i++) {\n      encode(encoder, value[i]);\n    }\n  } // bin 8 -- 0xc4\n  // bin 16 -- 0xc5\n  // bin 32 -- 0xc6\n\n\n  function bin_buffer(encoder, value) {\n    var length = value.length;\n    var type = length < 0xFF ? 0xc4 : length <= 0xFFFF ? 0xc5 : 0xc6;\n    token[type](encoder, length);\n    encoder.send(value);\n  }\n\n  function bin_arraybuffer(encoder, value) {\n    bin_buffer(encoder, new Uint8Array(value));\n  } // fixext 1 -- 0xd4\n  // fixext 2 -- 0xd5\n  // fixext 4 -- 0xd6\n  // fixext 8 -- 0xd7\n  // fixext 16 -- 0xd8\n  // ext 8 -- 0xc7\n  // ext 16 -- 0xc8\n  // ext 32 -- 0xc9\n\n\n  function ext(encoder, value) {\n    var buffer = value.buffer;\n    var length = buffer.length;\n    var type = extmap[length] || (length < 0xFF ? 0xc7 : length <= 0xFFFF ? 0xc8 : 0xc9);\n    token[type](encoder, length);\n    uint8[value.type](encoder);\n    encoder.send(buffer);\n  } // fixmap -- 0x80 - 0x8f\n  // map 16 -- 0xde\n  // map 32 -- 0xdf\n\n\n  function obj_to_map(encoder, value) {\n    var keys = Object.keys(value);\n    var length = keys.length;\n    var type = length < 16 ? 0x80 + length : length <= 0xFFFF ? 0xde : 0xdf;\n    token[type](encoder, length);\n    var encode = encoder.codec.encode;\n    keys.forEach(function (key) {\n      encode(encoder, key);\n      encode(encoder, value[key]);\n    });\n  } // fixmap -- 0x80 - 0x8f\n  // map 16 -- 0xde\n  // map 32 -- 0xdf\n\n\n  function map_to_map(encoder, value) {\n    if (!(value instanceof Map)) return obj_to_map(encoder, value);\n    var length = value.size;\n    var type = length < 16 ? 0x80 + length : length <= 0xFFFF ? 0xde : 0xdf;\n    token[type](encoder, length);\n    var encode = encoder.codec.encode;\n    value.forEach(function (val, key, m) {\n      encode(encoder, key);\n      encode(encoder, val);\n    });\n  } // raw 16 -- 0xda\n  // raw 32 -- 0xdb\n  // fixraw -- 0xa0 - 0xbf\n\n\n  function raw(encoder, value) {\n    var length = value.length;\n    var type = length < 32 ? 0xa0 + length : length <= 0xFFFF ? 0xda : 0xdb;\n    token[type](encoder, length);\n    encoder.send(value);\n  }\n}","map":{"version":3,"sources":["C:/Users/kohmu/udonarium/node_modules/msgpack-lite/lib/write-type.js"],"names":["IS_ARRAY","require","Int64Buffer","Uint64BE","Int64BE","Bufferish","BufferProto","WriteToken","uint8","ExtBuffer","HAS_UINT8ARRAY","Uint8Array","HAS_MAP","Map","extmap","exports","getWriteType","options","token","getWriteToken","useraw","binarraybuffer","isBuffer","isArrayBuffer","bin","bin_arraybuffer","bin_buffer","usemap","map","map_to_map","obj_to_map","writeType","bool","nil","number","object_raw","object","_string","raw_head_size","str_head_size","encoder","value","type","ivalue","uint64","toArray","int64","length","head_size","string","maxsize","offset","reserve","buffer","expected","start","write","call","actual","targetStart","end","copy","array","isUint64BE","isInt64BE","packer","codec","getExtPacker","ext","raw","encode","i","send","keys","Object","forEach","key","size","val","m"],"mappings":"AAAA;AAEA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,SAAD,CAAtB;;AACA,IAAIC,WAAW,GAAGD,OAAO,CAAC,cAAD,CAAzB;;AACA,IAAIE,QAAQ,GAAGD,WAAW,CAACC,QAA3B;AACA,IAAIC,OAAO,GAAGF,WAAW,CAACE,OAA1B;;AAEA,IAAIC,SAAS,GAAGJ,OAAO,CAAC,aAAD,CAAvB;;AACA,IAAIK,WAAW,GAAGL,OAAO,CAAC,mBAAD,CAAzB;;AACA,IAAIM,UAAU,GAAGN,OAAO,CAAC,eAAD,CAAxB;;AACA,IAAIO,KAAK,GAAGP,OAAO,CAAC,eAAD,CAAP,CAAyBO,KAArC;;AACA,IAAIC,SAAS,GAAGR,OAAO,CAAC,cAAD,CAAP,CAAwBQ,SAAxC;;AAEA,IAAIC,cAAc,GAAI,gBAAgB,OAAOC,UAA7C;AACA,IAAIC,OAAO,GAAI,gBAAgB,OAAOC,GAAtC;AAEA,IAAIC,MAAM,GAAG,EAAb;AACAA,MAAM,CAAC,CAAD,CAAN,GAAY,IAAZ;AACAA,MAAM,CAAC,CAAD,CAAN,GAAY,IAAZ;AACAA,MAAM,CAAC,CAAD,CAAN,GAAY,IAAZ;AACAA,MAAM,CAAC,CAAD,CAAN,GAAY,IAAZ;AACAA,MAAM,CAAC,EAAD,CAAN,GAAa,IAAb;AAEAC,OAAO,CAACC,YAAR,GAAuBA,YAAvB;;AAEA,SAASA,YAAT,CAAsBC,OAAtB,EAA+B;AAC7B,MAAIC,KAAK,GAAGX,UAAU,CAACY,aAAX,CAAyBF,OAAzB,CAAZ;AACA,MAAIG,MAAM,GAAGH,OAAO,IAAIA,OAAO,CAACG,MAAhC;AACA,MAAIC,cAAc,GAAGX,cAAc,IAAIO,OAAlB,IAA6BA,OAAO,CAACI,cAA1D;AACA,MAAIC,QAAQ,GAAGD,cAAc,GAAGhB,SAAS,CAACkB,aAAb,GAA6BlB,SAAS,CAACiB,QAApE;AACA,MAAIE,GAAG,GAAGH,cAAc,GAAGI,eAAH,GAAqBC,UAA7C;AACA,MAAIC,MAAM,GAAGf,OAAO,IAAIK,OAAX,IAAsBA,OAAO,CAACU,MAA3C;AACA,MAAIC,GAAG,GAAGD,MAAM,GAAGE,UAAH,GAAgBC,UAAhC;AAEA,MAAIC,SAAS,GAAG;AACd,eAAWC,IADG;AAEd,gBAAYC,GAFE;AAGd,cAAUC,MAHI;AAId,cAAWd,MAAM,GAAGe,UAAH,GAAgBC,MAJnB;AAKd,cAAUC,OAAO,CAACjB,MAAM,GAAGkB,aAAH,GAAmBC,aAA1B,CALH;AAMd,cAAUN,GANI;AAOd,iBAAaA;AAPC,GAAhB;AAUA,SAAOF,SAAP,CAnB6B,CAqB7B;AACA;;AACA,WAASC,IAAT,CAAcQ,OAAd,EAAuBC,KAAvB,EAA8B;AAC5B,QAAIC,IAAI,GAAGD,KAAK,GAAG,IAAH,GAAU,IAA1B;AACAvB,IAAAA,KAAK,CAACwB,IAAD,CAAL,CAAYF,OAAZ,EAAqBC,KAArB;AACD;;AAED,WAASP,MAAT,CAAgBM,OAAhB,EAAyBC,KAAzB,EAAgC;AAC9B,QAAIE,MAAM,GAAGF,KAAK,GAAG,CAArB;AACA,QAAIC,IAAJ;;AACA,QAAID,KAAK,KAAKE,MAAd,EAAsB;AACpB;AACAD,MAAAA,IAAI,GAAG,IAAP;AACAxB,MAAAA,KAAK,CAACwB,IAAD,CAAL,CAAYF,OAAZ,EAAqBC,KAArB;AACA;AACD,KALD,MAKO,IAAI,CAAC,IAAD,IAASE,MAAT,IAAmBA,MAAM,IAAI,IAAjC,EAAuC;AAC5C;AACA;AACAD,MAAAA,IAAI,GAAGC,MAAM,GAAG,IAAhB;AACD,KAJM,MAIA,IAAI,KAAKA,MAAT,EAAiB;AACtB;AACA;AACA;AACAD,MAAAA,IAAI,GAAIC,MAAM,IAAI,IAAX,GAAmB,IAAnB,GAA2BA,MAAM,IAAI,MAAX,GAAqB,IAArB,GAA4B,IAA7D;AACD,KALM,MAKA;AACL;AACA;AACA;AACAD,MAAAA,IAAI,GAAI,CAAC,IAAD,IAASC,MAAV,GAAoB,IAApB,GAA4B,CAAC,MAAD,IAAWA,MAAZ,GAAsB,IAAtB,GAA6B,IAA/D;AACD;;AACDzB,IAAAA,KAAK,CAACwB,IAAD,CAAL,CAAYF,OAAZ,EAAqBG,MAArB;AACD,GApD4B,CAsD7B;;;AACA,WAASC,MAAT,CAAgBJ,OAAhB,EAAyBC,KAAzB,EAAgC;AAC9B,QAAIC,IAAI,GAAG,IAAX;AACAxB,IAAAA,KAAK,CAACwB,IAAD,CAAL,CAAYF,OAAZ,EAAqBC,KAAK,CAACI,OAAN,EAArB;AACD,GA1D4B,CA4D7B;;;AACA,WAASC,KAAT,CAAeN,OAAf,EAAwBC,KAAxB,EAA+B;AAC7B,QAAIC,IAAI,GAAG,IAAX;AACAxB,IAAAA,KAAK,CAACwB,IAAD,CAAL,CAAYF,OAAZ,EAAqBC,KAAK,CAACI,OAAN,EAArB;AACD,GAhE4B,CAkE7B;AACA;AACA;AACA;;;AACA,WAASN,aAAT,CAAuBQ,MAAvB,EAA+B;AAC7B,WAAQA,MAAM,GAAG,EAAV,GAAgB,CAAhB,GAAqBA,MAAM,IAAI,IAAX,GAAmB,CAAnB,GAAwBA,MAAM,IAAI,MAAX,GAAqB,CAArB,GAAyB,CAA3E;AACD,GAxE4B,CA0E7B;AACA;AACA;;;AACA,WAAST,aAAT,CAAuBS,MAAvB,EAA+B;AAC7B,WAAQA,MAAM,GAAG,EAAV,GAAgB,CAAhB,GAAqBA,MAAM,IAAI,MAAX,GAAqB,CAArB,GAAyB,CAApD;AACD;;AAED,WAASV,OAAT,CAAiBW,SAAjB,EAA4B;AAC1B,WAAOC,MAAP;;AAEA,aAASA,MAAT,CAAgBT,OAAhB,EAAyBC,KAAzB,EAAgC;AAC9B;AACA,UAAIM,MAAM,GAAGN,KAAK,CAACM,MAAnB;AACA,UAAIG,OAAO,GAAG,IAAIH,MAAM,GAAG,CAA3B;AACAP,MAAAA,OAAO,CAACW,MAAR,GAAiBX,OAAO,CAACY,OAAR,CAAgBF,OAAhB,CAAjB;AACA,UAAIG,MAAM,GAAGb,OAAO,CAACa,MAArB,CAL8B,CAO9B;;AACA,UAAIC,QAAQ,GAAGN,SAAS,CAACD,MAAD,CAAxB,CAR8B,CAU9B;;AACA,UAAIQ,KAAK,GAAGf,OAAO,CAACW,MAAR,GAAiBG,QAA7B,CAX8B,CAa9B;;AACAP,MAAAA,MAAM,GAAGzC,WAAW,CAACkD,KAAZ,CAAkBC,IAAlB,CAAuBJ,MAAvB,EAA+BZ,KAA/B,EAAsCc,KAAtC,CAAT,CAd8B,CAgB9B;;AACA,UAAIG,MAAM,GAAGV,SAAS,CAACD,MAAD,CAAtB,CAjB8B,CAmB9B;;AACA,UAAIO,QAAQ,KAAKI,MAAjB,EAAyB;AACvB,YAAIC,WAAW,GAAGJ,KAAK,GAAGG,MAAR,GAAiBJ,QAAnC;AACA,YAAIM,GAAG,GAAGL,KAAK,GAAGR,MAAlB;AACAzC,QAAAA,WAAW,CAACuD,IAAZ,CAAiBJ,IAAjB,CAAsBJ,MAAtB,EAA8BA,MAA9B,EAAsCM,WAAtC,EAAmDJ,KAAnD,EAA0DK,GAA1D;AACD,OAxB6B,CA0B9B;;;AACA,UAAIlB,IAAI,GAAIgB,MAAM,KAAK,CAAZ,GAAkB,OAAOX,MAAzB,GAAoCW,MAAM,IAAI,CAAX,GAAiB,OAAOA,MAAxB,GAAkC,IAAhF;AACAxC,MAAAA,KAAK,CAACwB,IAAD,CAAL,CAAYF,OAAZ,EAAqBO,MAArB,EA5B8B,CA8B9B;;AACAP,MAAAA,OAAO,CAACW,MAAR,IAAkBJ,MAAlB;AACD;AACF;;AAED,WAASX,MAAT,CAAgBI,OAAhB,EAAyBC,KAAzB,EAAgC;AAC9B;AACA,QAAIA,KAAK,KAAK,IAAd,EAAoB,OAAOR,GAAG,CAACO,OAAD,EAAUC,KAAV,CAAV,CAFU,CAI9B;;AACA,QAAInB,QAAQ,CAACmB,KAAD,CAAZ,EAAqB,OAAOjB,GAAG,CAACgB,OAAD,EAAUC,KAAV,CAAV,CALS,CAO9B;;AACA,QAAIzC,QAAQ,CAACyC,KAAD,CAAZ,EAAqB,OAAOqB,KAAK,CAACtB,OAAD,EAAUC,KAAV,CAAZ,CARS,CAU9B;;AACA,QAAItC,QAAQ,CAAC4D,UAAT,CAAoBtB,KAApB,CAAJ,EAAgC,OAAOG,MAAM,CAACJ,OAAD,EAAUC,KAAV,CAAb;AAChC,QAAIrC,OAAO,CAAC4D,SAAR,CAAkBvB,KAAlB,CAAJ,EAA8B,OAAOK,KAAK,CAACN,OAAD,EAAUC,KAAV,CAAZ,CAZA,CAc9B;;AACA,QAAIwB,MAAM,GAAGzB,OAAO,CAAC0B,KAAR,CAAcC,YAAd,CAA2B1B,KAA3B,CAAb;AACA,QAAIwB,MAAJ,EAAYxB,KAAK,GAAGwB,MAAM,CAACxB,KAAD,CAAd;AACZ,QAAIA,KAAK,YAAYhC,SAArB,EAAgC,OAAO2D,GAAG,CAAC5B,OAAD,EAAUC,KAAV,CAAV,CAjBF,CAmB9B;;AACAb,IAAAA,GAAG,CAACY,OAAD,EAAUC,KAAV,CAAH;AACD;;AAED,WAASN,UAAT,CAAoBK,OAApB,EAA6BC,KAA7B,EAAoC;AAClC;AACA,QAAInB,QAAQ,CAACmB,KAAD,CAAZ,EAAqB,OAAO4B,GAAG,CAAC7B,OAAD,EAAUC,KAAV,CAAV,CAFa,CAIlC;;AACAL,IAAAA,MAAM,CAACI,OAAD,EAAUC,KAAV,CAAN;AACD,GApJ4B,CAsJ7B;;;AACA,WAASR,GAAT,CAAaO,OAAb,EAAsBC,KAAtB,EAA6B;AAC3B,QAAIC,IAAI,GAAG,IAAX;AACAxB,IAAAA,KAAK,CAACwB,IAAD,CAAL,CAAYF,OAAZ,EAAqBC,KAArB;AACD,GA1J4B,CA4J7B;AACA;AACA;;;AACA,WAASqB,KAAT,CAAetB,OAAf,EAAwBC,KAAxB,EAA+B;AAC7B,QAAIM,MAAM,GAAGN,KAAK,CAACM,MAAnB;AACA,QAAIL,IAAI,GAAIK,MAAM,GAAG,EAAV,GAAiB,OAAOA,MAAxB,GAAmCA,MAAM,IAAI,MAAX,GAAqB,IAArB,GAA4B,IAAzE;AACA7B,IAAAA,KAAK,CAACwB,IAAD,CAAL,CAAYF,OAAZ,EAAqBO,MAArB;AAEA,QAAIuB,MAAM,GAAG9B,OAAO,CAAC0B,KAAR,CAAcI,MAA3B;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGxB,MAApB,EAA4BwB,CAAC,EAA7B,EAAiC;AAC/BD,MAAAA,MAAM,CAAC9B,OAAD,EAAUC,KAAK,CAAC8B,CAAD,CAAf,CAAN;AACD;AACF,GAxK4B,CA0K7B;AACA;AACA;;;AACA,WAAS7C,UAAT,CAAoBc,OAApB,EAA6BC,KAA7B,EAAoC;AAClC,QAAIM,MAAM,GAAGN,KAAK,CAACM,MAAnB;AACA,QAAIL,IAAI,GAAIK,MAAM,GAAG,IAAV,GAAkB,IAAlB,GAA0BA,MAAM,IAAI,MAAX,GAAqB,IAArB,GAA4B,IAAhE;AACA7B,IAAAA,KAAK,CAACwB,IAAD,CAAL,CAAYF,OAAZ,EAAqBO,MAArB;AACAP,IAAAA,OAAO,CAACgC,IAAR,CAAa/B,KAAb;AACD;;AAED,WAAShB,eAAT,CAAyBe,OAAzB,EAAkCC,KAAlC,EAAyC;AACvCf,IAAAA,UAAU,CAACc,OAAD,EAAU,IAAI7B,UAAJ,CAAe8B,KAAf,CAAV,CAAV;AACD,GAtL4B,CAwL7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,WAAS2B,GAAT,CAAa5B,OAAb,EAAsBC,KAAtB,EAA6B;AAC3B,QAAIY,MAAM,GAAGZ,KAAK,CAACY,MAAnB;AACA,QAAIN,MAAM,GAAGM,MAAM,CAACN,MAApB;AACA,QAAIL,IAAI,GAAG5B,MAAM,CAACiC,MAAD,CAAN,KAAoBA,MAAM,GAAG,IAAV,GAAkB,IAAlB,GAA0BA,MAAM,IAAI,MAAX,GAAqB,IAArB,GAA4B,IAAxE,CAAX;AACA7B,IAAAA,KAAK,CAACwB,IAAD,CAAL,CAAYF,OAAZ,EAAqBO,MAArB;AACAvC,IAAAA,KAAK,CAACiC,KAAK,CAACC,IAAP,CAAL,CAAkBF,OAAlB;AACAA,IAAAA,OAAO,CAACgC,IAAR,CAAanB,MAAb;AACD,GAvM4B,CAyM7B;AACA;AACA;;;AACA,WAASvB,UAAT,CAAoBU,OAApB,EAA6BC,KAA7B,EAAoC;AAClC,QAAIgC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYhC,KAAZ,CAAX;AACA,QAAIM,MAAM,GAAG0B,IAAI,CAAC1B,MAAlB;AACA,QAAIL,IAAI,GAAIK,MAAM,GAAG,EAAV,GAAiB,OAAOA,MAAxB,GAAmCA,MAAM,IAAI,MAAX,GAAqB,IAArB,GAA4B,IAAzE;AACA7B,IAAAA,KAAK,CAACwB,IAAD,CAAL,CAAYF,OAAZ,EAAqBO,MAArB;AAEA,QAAIuB,MAAM,GAAG9B,OAAO,CAAC0B,KAAR,CAAcI,MAA3B;AACAG,IAAAA,IAAI,CAACE,OAAL,CAAa,UAASC,GAAT,EAAc;AACzBN,MAAAA,MAAM,CAAC9B,OAAD,EAAUoC,GAAV,CAAN;AACAN,MAAAA,MAAM,CAAC9B,OAAD,EAAUC,KAAK,CAACmC,GAAD,CAAf,CAAN;AACD,KAHD;AAID,GAvN4B,CAyN7B;AACA;AACA;;;AACA,WAAS/C,UAAT,CAAoBW,OAApB,EAA6BC,KAA7B,EAAoC;AAClC,QAAI,EAAEA,KAAK,YAAY5B,GAAnB,CAAJ,EAA6B,OAAOiB,UAAU,CAACU,OAAD,EAAUC,KAAV,CAAjB;AAE7B,QAAIM,MAAM,GAAGN,KAAK,CAACoC,IAAnB;AACA,QAAInC,IAAI,GAAIK,MAAM,GAAG,EAAV,GAAiB,OAAOA,MAAxB,GAAmCA,MAAM,IAAI,MAAX,GAAqB,IAArB,GAA4B,IAAzE;AACA7B,IAAAA,KAAK,CAACwB,IAAD,CAAL,CAAYF,OAAZ,EAAqBO,MAArB;AAEA,QAAIuB,MAAM,GAAG9B,OAAO,CAAC0B,KAAR,CAAcI,MAA3B;AACA7B,IAAAA,KAAK,CAACkC,OAAN,CAAc,UAASG,GAAT,EAAcF,GAAd,EAAmBG,CAAnB,EAAsB;AAClCT,MAAAA,MAAM,CAAC9B,OAAD,EAAUoC,GAAV,CAAN;AACAN,MAAAA,MAAM,CAAC9B,OAAD,EAAUsC,GAAV,CAAN;AACD,KAHD;AAID,GAxO4B,CA0O7B;AACA;AACA;;;AACA,WAAST,GAAT,CAAa7B,OAAb,EAAsBC,KAAtB,EAA6B;AAC3B,QAAIM,MAAM,GAAGN,KAAK,CAACM,MAAnB;AACA,QAAIL,IAAI,GAAIK,MAAM,GAAG,EAAV,GAAiB,OAAOA,MAAxB,GAAmCA,MAAM,IAAI,MAAX,GAAqB,IAArB,GAA4B,IAAzE;AACA7B,IAAAA,KAAK,CAACwB,IAAD,CAAL,CAAYF,OAAZ,EAAqBO,MAArB;AACAP,IAAAA,OAAO,CAACgC,IAAR,CAAa/B,KAAb;AACD;AACF","sourcesContent":["// write-type.js\n\nvar IS_ARRAY = require(\"isarray\");\nvar Int64Buffer = require(\"int64-buffer\");\nvar Uint64BE = Int64Buffer.Uint64BE;\nvar Int64BE = Int64Buffer.Int64BE;\n\nvar Bufferish = require(\"./bufferish\");\nvar BufferProto = require(\"./bufferish-proto\");\nvar WriteToken = require(\"./write-token\");\nvar uint8 = require(\"./write-uint8\").uint8;\nvar ExtBuffer = require(\"./ext-buffer\").ExtBuffer;\n\nvar HAS_UINT8ARRAY = (\"undefined\" !== typeof Uint8Array);\nvar HAS_MAP = (\"undefined\" !== typeof Map);\n\nvar extmap = [];\nextmap[1] = 0xd4;\nextmap[2] = 0xd5;\nextmap[4] = 0xd6;\nextmap[8] = 0xd7;\nextmap[16] = 0xd8;\n\nexports.getWriteType = getWriteType;\n\nfunction getWriteType(options) {\n  var token = WriteToken.getWriteToken(options);\n  var useraw = options && options.useraw;\n  var binarraybuffer = HAS_UINT8ARRAY && options && options.binarraybuffer;\n  var isBuffer = binarraybuffer ? Bufferish.isArrayBuffer : Bufferish.isBuffer;\n  var bin = binarraybuffer ? bin_arraybuffer : bin_buffer;\n  var usemap = HAS_MAP && options && options.usemap;\n  var map = usemap ? map_to_map : obj_to_map;\n\n  var writeType = {\n    \"boolean\": bool,\n    \"function\": nil,\n    \"number\": number,\n    \"object\": (useraw ? object_raw : object),\n    \"string\": _string(useraw ? raw_head_size : str_head_size),\n    \"symbol\": nil,\n    \"undefined\": nil\n  };\n\n  return writeType;\n\n  // false -- 0xc2\n  // true -- 0xc3\n  function bool(encoder, value) {\n    var type = value ? 0xc3 : 0xc2;\n    token[type](encoder, value);\n  }\n\n  function number(encoder, value) {\n    var ivalue = value | 0;\n    var type;\n    if (value !== ivalue) {\n      // float 64 -- 0xcb\n      type = 0xcb;\n      token[type](encoder, value);\n      return;\n    } else if (-0x20 <= ivalue && ivalue <= 0x7F) {\n      // positive fixint -- 0x00 - 0x7f\n      // negative fixint -- 0xe0 - 0xff\n      type = ivalue & 0xFF;\n    } else if (0 <= ivalue) {\n      // uint 8 -- 0xcc\n      // uint 16 -- 0xcd\n      // uint 32 -- 0xce\n      type = (ivalue <= 0xFF) ? 0xcc : (ivalue <= 0xFFFF) ? 0xcd : 0xce;\n    } else {\n      // int 8 -- 0xd0\n      // int 16 -- 0xd1\n      // int 32 -- 0xd2\n      type = (-0x80 <= ivalue) ? 0xd0 : (-0x8000 <= ivalue) ? 0xd1 : 0xd2;\n    }\n    token[type](encoder, ivalue);\n  }\n\n  // uint 64 -- 0xcf\n  function uint64(encoder, value) {\n    var type = 0xcf;\n    token[type](encoder, value.toArray());\n  }\n\n  // int 64 -- 0xd3\n  function int64(encoder, value) {\n    var type = 0xd3;\n    token[type](encoder, value.toArray());\n  }\n\n  // str 8 -- 0xd9\n  // str 16 -- 0xda\n  // str 32 -- 0xdb\n  // fixstr -- 0xa0 - 0xbf\n  function str_head_size(length) {\n    return (length < 32) ? 1 : (length <= 0xFF) ? 2 : (length <= 0xFFFF) ? 3 : 5;\n  }\n\n  // raw 16 -- 0xda\n  // raw 32 -- 0xdb\n  // fixraw -- 0xa0 - 0xbf\n  function raw_head_size(length) {\n    return (length < 32) ? 1 : (length <= 0xFFFF) ? 3 : 5;\n  }\n\n  function _string(head_size) {\n    return string;\n\n    function string(encoder, value) {\n      // prepare buffer\n      var length = value.length;\n      var maxsize = 5 + length * 3;\n      encoder.offset = encoder.reserve(maxsize);\n      var buffer = encoder.buffer;\n\n      // expected header size\n      var expected = head_size(length);\n\n      // expected start point\n      var start = encoder.offset + expected;\n\n      // write string\n      length = BufferProto.write.call(buffer, value, start);\n\n      // actual header size\n      var actual = head_size(length);\n\n      // move content when needed\n      if (expected !== actual) {\n        var targetStart = start + actual - expected;\n        var end = start + length;\n        BufferProto.copy.call(buffer, buffer, targetStart, start, end);\n      }\n\n      // write header\n      var type = (actual === 1) ? (0xa0 + length) : (actual <= 3) ? (0xd7 + actual) : 0xdb;\n      token[type](encoder, length);\n\n      // move cursor\n      encoder.offset += length;\n    }\n  }\n\n  function object(encoder, value) {\n    // null\n    if (value === null) return nil(encoder, value);\n\n    // Buffer\n    if (isBuffer(value)) return bin(encoder, value);\n\n    // Array\n    if (IS_ARRAY(value)) return array(encoder, value);\n\n    // int64-buffer objects\n    if (Uint64BE.isUint64BE(value)) return uint64(encoder, value);\n    if (Int64BE.isInt64BE(value)) return int64(encoder, value);\n\n    // ext formats\n    var packer = encoder.codec.getExtPacker(value);\n    if (packer) value = packer(value);\n    if (value instanceof ExtBuffer) return ext(encoder, value);\n\n    // plain old Objects or Map\n    map(encoder, value);\n  }\n\n  function object_raw(encoder, value) {\n    // Buffer\n    if (isBuffer(value)) return raw(encoder, value);\n\n    // others\n    object(encoder, value);\n  }\n\n  // nil -- 0xc0\n  function nil(encoder, value) {\n    var type = 0xc0;\n    token[type](encoder, value);\n  }\n\n  // fixarray -- 0x90 - 0x9f\n  // array 16 -- 0xdc\n  // array 32 -- 0xdd\n  function array(encoder, value) {\n    var length = value.length;\n    var type = (length < 16) ? (0x90 + length) : (length <= 0xFFFF) ? 0xdc : 0xdd;\n    token[type](encoder, length);\n\n    var encode = encoder.codec.encode;\n    for (var i = 0; i < length; i++) {\n      encode(encoder, value[i]);\n    }\n  }\n\n  // bin 8 -- 0xc4\n  // bin 16 -- 0xc5\n  // bin 32 -- 0xc6\n  function bin_buffer(encoder, value) {\n    var length = value.length;\n    var type = (length < 0xFF) ? 0xc4 : (length <= 0xFFFF) ? 0xc5 : 0xc6;\n    token[type](encoder, length);\n    encoder.send(value);\n  }\n\n  function bin_arraybuffer(encoder, value) {\n    bin_buffer(encoder, new Uint8Array(value));\n  }\n\n  // fixext 1 -- 0xd4\n  // fixext 2 -- 0xd5\n  // fixext 4 -- 0xd6\n  // fixext 8 -- 0xd7\n  // fixext 16 -- 0xd8\n  // ext 8 -- 0xc7\n  // ext 16 -- 0xc8\n  // ext 32 -- 0xc9\n  function ext(encoder, value) {\n    var buffer = value.buffer;\n    var length = buffer.length;\n    var type = extmap[length] || ((length < 0xFF) ? 0xc7 : (length <= 0xFFFF) ? 0xc8 : 0xc9);\n    token[type](encoder, length);\n    uint8[value.type](encoder);\n    encoder.send(buffer);\n  }\n\n  // fixmap -- 0x80 - 0x8f\n  // map 16 -- 0xde\n  // map 32 -- 0xdf\n  function obj_to_map(encoder, value) {\n    var keys = Object.keys(value);\n    var length = keys.length;\n    var type = (length < 16) ? (0x80 + length) : (length <= 0xFFFF) ? 0xde : 0xdf;\n    token[type](encoder, length);\n\n    var encode = encoder.codec.encode;\n    keys.forEach(function(key) {\n      encode(encoder, key);\n      encode(encoder, value[key]);\n    });\n  }\n\n  // fixmap -- 0x80 - 0x8f\n  // map 16 -- 0xde\n  // map 32 -- 0xdf\n  function map_to_map(encoder, value) {\n    if (!(value instanceof Map)) return obj_to_map(encoder, value);\n\n    var length = value.size;\n    var type = (length < 16) ? (0x80 + length) : (length <= 0xFFFF) ? 0xde : 0xdf;\n    token[type](encoder, length);\n\n    var encode = encoder.codec.encode;\n    value.forEach(function(val, key, m) {\n      encode(encoder, key);\n      encode(encoder, val);\n    });\n  }\n\n  // raw 16 -- 0xda\n  // raw 32 -- 0xdb\n  // fixraw -- 0xa0 - 0xbf\n  function raw(encoder, value) {\n    var length = value.length;\n    var type = (length < 32) ? (0xa0 + length) : (length <= 0xFFFF) ? 0xda : 0xdb;\n    token[type](encoder, length);\n    encoder.send(value);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}