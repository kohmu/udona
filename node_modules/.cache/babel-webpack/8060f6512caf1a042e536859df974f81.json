{"ast":null,"code":"// write-type.js\nvar IS_ARRAY = require(\"isarray\");\n\nvar Int64Buffer = require(\"int64-buffer\");\n\nvar Uint64BE = Int64Buffer.Uint64BE;\nvar Int64BE = Int64Buffer.Int64BE;\n\nvar Bufferish = require(\"./bufferish\");\n\nvar BufferProto = require(\"./bufferish-proto\");\n\nvar WriteToken = require(\"./write-token\");\n\nvar uint8 = require(\"./write-uint8\").uint8;\n\nvar ExtBuffer = require(\"./ext-buffer\").ExtBuffer;\n\nvar HAS_UINT8ARRAY = \"undefined\" !== typeof Uint8Array;\nvar HAS_MAP = \"undefined\" !== typeof Map;\nvar extmap = [];\nextmap[1] = 0xd4;\nextmap[2] = 0xd5;\nextmap[4] = 0xd6;\nextmap[8] = 0xd7;\nextmap[16] = 0xd8;\nexports.getWriteType = getWriteType;\n\nfunction getWriteType(options) {\n  var token = WriteToken.getWriteToken(options);\n  var useraw = options && options.useraw;\n  var binarraybuffer = HAS_UINT8ARRAY && options && options.binarraybuffer;\n  var isBuffer = binarraybuffer ? Bufferish.isArrayBuffer : Bufferish.isBuffer;\n  var bin = binarraybuffer ? bin_arraybuffer : bin_buffer;\n  var usemap = HAS_MAP && options && options.usemap;\n  var map = usemap ? map_to_map : obj_to_map;\n  var writeType = {\n    \"boolean\": bool,\n    \"function\": nil,\n    \"number\": number,\n    \"object\": useraw ? object_raw : object,\n    \"string\": _string(useraw ? raw_head_size : str_head_size),\n    \"symbol\": nil,\n    \"undefined\": nil\n  };\n  return writeType; // false -- 0xc2\n  // true -- 0xc3\n\n  function bool(encoder, value) {\n    var type = value ? 0xc3 : 0xc2;\n    token[type](encoder, value);\n  }\n\n  function number(encoder, value) {\n    var ivalue = value | 0;\n    var type;\n\n    if (value !== ivalue) {\n      // float 64 -- 0xcb\n      type = 0xcb;\n      token[type](encoder, value);\n      return;\n    } else if (-0x20 <= ivalue && ivalue <= 0x7F) {\n      // positive fixint -- 0x00 - 0x7f\n      // negative fixint -- 0xe0 - 0xff\n      type = ivalue & 0xFF;\n    } else if (0 <= ivalue) {\n      // uint 8 -- 0xcc\n      // uint 16 -- 0xcd\n      // uint 32 -- 0xce\n      type = ivalue <= 0xFF ? 0xcc : ivalue <= 0xFFFF ? 0xcd : 0xce;\n    } else {\n      // int 8 -- 0xd0\n      // int 16 -- 0xd1\n      // int 32 -- 0xd2\n      type = -0x80 <= ivalue ? 0xd0 : -0x8000 <= ivalue ? 0xd1 : 0xd2;\n    }\n\n    token[type](encoder, ivalue);\n  } // uint 64 -- 0xcf\n\n\n  function uint64(encoder, value) {\n    var type = 0xcf;\n    token[type](encoder, value.toArray());\n  } // int 64 -- 0xd3\n\n\n  function int64(encoder, value) {\n    var type = 0xd3;\n    token[type](encoder, value.toArray());\n  } // str 8 -- 0xd9\n  // str 16 -- 0xda\n  // str 32 -- 0xdb\n  // fixstr -- 0xa0 - 0xbf\n\n\n  function str_head_size(length) {\n    return length < 32 ? 1 : length <= 0xFF ? 2 : length <= 0xFFFF ? 3 : 5;\n  } // raw 16 -- 0xda\n  // raw 32 -- 0xdb\n  // fixraw -- 0xa0 - 0xbf\n\n\n  function raw_head_size(length) {\n    return length < 32 ? 1 : length <= 0xFFFF ? 3 : 5;\n  }\n\n  function _string(head_size) {\n    return string;\n\n    function string(encoder, value) {\n      // prepare buffer\n      var length = value.length;\n      var maxsize = 5 + length * 3;\n      encoder.offset = encoder.reserve(maxsize);\n      var buffer = encoder.buffer; // expected header size\n\n      var expected = head_size(length); // expected start point\n\n      var start = encoder.offset + expected; // write string\n\n      length = BufferProto.write.call(buffer, value, start); // actual header size\n\n      var actual = head_size(length); // move content when needed\n\n      if (expected !== actual) {\n        var targetStart = start + actual - expected;\n        var end = start + length;\n        BufferProto.copy.call(buffer, buffer, targetStart, start, end);\n      } // write header\n\n\n      var type = actual === 1 ? 0xa0 + length : actual <= 3 ? 0xd7 + actual : 0xdb;\n      token[type](encoder, length); // move cursor\n\n      encoder.offset += length;\n    }\n  }\n\n  function object(encoder, value) {\n    // null\n    if (value === null) return nil(encoder, value); // Buffer\n\n    if (isBuffer(value)) return bin(encoder, value); // Array\n\n    if (IS_ARRAY(value)) return array(encoder, value); // int64-buffer objects\n\n    if (Uint64BE.isUint64BE(value)) return uint64(encoder, value);\n    if (Int64BE.isInt64BE(value)) return int64(encoder, value); // ext formats\n\n    var packer = encoder.codec.getExtPacker(value);\n    if (packer) value = packer(value);\n    if (value instanceof ExtBuffer) return ext(encoder, value); // plain old Objects or Map\n\n    map(encoder, value);\n  }\n\n  function object_raw(encoder, value) {\n    // Buffer\n    if (isBuffer(value)) return raw(encoder, value); // others\n\n    object(encoder, value);\n  } // nil -- 0xc0\n\n\n  function nil(encoder, value) {\n    var type = 0xc0;\n    token[type](encoder, value);\n  } // fixarray -- 0x90 - 0x9f\n  // array 16 -- 0xdc\n  // array 32 -- 0xdd\n\n\n  function array(encoder, value) {\n    var length = value.length;\n    var type = length < 16 ? 0x90 + length : length <= 0xFFFF ? 0xdc : 0xdd;\n    token[type](encoder, length);\n    var encode = encoder.codec.encode;\n\n    for (var i = 0; i < length; i++) {\n      encode(encoder, value[i]);\n    }\n  } // bin 8 -- 0xc4\n  // bin 16 -- 0xc5\n  // bin 32 -- 0xc6\n\n\n  function bin_buffer(encoder, value) {\n    var length = value.length;\n    var type = length < 0xFF ? 0xc4 : length <= 0xFFFF ? 0xc5 : 0xc6;\n    token[type](encoder, length);\n    encoder.send(value);\n  }\n\n  function bin_arraybuffer(encoder, value) {\n    bin_buffer(encoder, new Uint8Array(value));\n  } // fixext 1 -- 0xd4\n  // fixext 2 -- 0xd5\n  // fixext 4 -- 0xd6\n  // fixext 8 -- 0xd7\n  // fixext 16 -- 0xd8\n  // ext 8 -- 0xc7\n  // ext 16 -- 0xc8\n  // ext 32 -- 0xc9\n\n\n  function ext(encoder, value) {\n    var buffer = value.buffer;\n    var length = buffer.length;\n    var type = extmap[length] || (length < 0xFF ? 0xc7 : length <= 0xFFFF ? 0xc8 : 0xc9);\n    token[type](encoder, length);\n    uint8[value.type](encoder);\n    encoder.send(buffer);\n  } // fixmap -- 0x80 - 0x8f\n  // map 16 -- 0xde\n  // map 32 -- 0xdf\n\n\n  function obj_to_map(encoder, value) {\n    var keys = Object.keys(value);\n    var length = keys.length;\n    var type = length < 16 ? 0x80 + length : length <= 0xFFFF ? 0xde : 0xdf;\n    token[type](encoder, length);\n    var encode = encoder.codec.encode;\n    keys.forEach(function (key) {\n      encode(encoder, key);\n      encode(encoder, value[key]);\n    });\n  } // fixmap -- 0x80 - 0x8f\n  // map 16 -- 0xde\n  // map 32 -- 0xdf\n\n\n  function map_to_map(encoder, value) {\n    if (!(value instanceof Map)) return obj_to_map(encoder, value);\n    var length = value.size;\n    var type = length < 16 ? 0x80 + length : length <= 0xFFFF ? 0xde : 0xdf;\n    token[type](encoder, length);\n    var encode = encoder.codec.encode;\n    value.forEach(function (val, key, m) {\n      encode(encoder, key);\n      encode(encoder, val);\n    });\n  } // raw 16 -- 0xda\n  // raw 32 -- 0xdb\n  // fixraw -- 0xa0 - 0xbf\n\n\n  function raw(encoder, value) {\n    var length = value.length;\n    var type = length < 32 ? 0xa0 + length : length <= 0xFFFF ? 0xda : 0xdb;\n    token[type](encoder, length);\n    encoder.send(value);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}